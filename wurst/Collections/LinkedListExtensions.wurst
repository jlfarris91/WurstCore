package LinkedListExtensions
import LinkedList
import ErrorHandling
import ErrorIf
import WeightedSet
import Selector
import Func

// ============================================================================
public function LinkedList<T>.getRandom<T>() returns T
  let randomIndex = GetRandomInt(0, this.size())
  return this.get(randomIndex)

// ============================================================================
public function LinkedList<T>.getRandom<T>(int count) returns LinkedList<T>
  let output = new LinkedList<T>()
  for i = 0 to count - 1
    let randomIndex = GetRandomInt(0, this.size())
    output.add(this.get(randomIndex))
  return output

// ============================================================================
public function LinkedList<T>.getRandomUnique<T>(int count) returns LinkedList<T>
  let clone = new LinkedList<T>(this)
  let output = new LinkedList<T>()
  for i = 0 to count - 1
    let randomIndex = GetRandomInt(0, this.size())
    output.add(clone.get(randomIndex))
    clone.removeAt(randomIndex)
  destroy clone
  return output

// ============================================================================
public function LinkedList<T>.take<T>(int count) returns LinkedList<T>
  if (count == 0)
    error("Argument 'count' must be greater than 0")
  let newList = new LinkedList<T>()
  let iterator = this.iterator()
  for i = 0 to count - 1
    if (iterator.hasNext())
      newList.add(iterator.next())
  return newList

// ============================================================================
public function LinkedList<TElem>.toWeightedSet<TElem>(Selector<TElem, real> selector) returns WeightedSet<TElem>
  ErrorIf.argumentIsNull(selector, "selector")
  let output = new WeightedSet<TElem>()
  this.forEach(elem -> output.add(elem, selector.select(elem)))
  return output

// ============================================================================
public function LinkedList<TElem>.getLast<TElem>() returns TElem
  return this.isEmpty() ? null : this.get(this.size() - 1)

// ============================================================================
public function LinkedList<TElem>.select<TElem, TRet>(Func1<TElem, TRet> selector) returns LinkedList<TRet>
  let result = new LinkedList<TRet>
  for elem in this
    result.add(selector.call(elem))
  return result

// ============================================================================
// Automatically destroys the selected LinkedList<> after enumerating
public function LinkedList<TElem>.selectMany<TElem, TRet>(Func1<TElem, LinkedList<TRet>> selector) returns LinkedList<TRet>
  let result = new LinkedList<TRet>
  for elem in this
    let selectedElems = selector.call(elem)
    if (selectedElems != null)
      for selectedElem in selectedElems
        result.add(selectedElem)
      destroy selectedElems
  return result

// ============================================================================
// Does not destroy the selected LinkedList<> after enumerating
public function LinkedList<TElem>.selectManyOwned<TElem, TRet>(Func1<TElem, LinkedList<TRet>> selector) returns LinkedList<TRet>
  let result = new LinkedList<TRet>
  for elem in this
    let selectedElems = selector.call(elem)
    if (selectedElems != null)
      for selectedElem in selectedElems
        result.add(selectedElem)
  return result

// ============================================================================
//
// Tests
//
// ============================================================================

@test
function take()
  // arrange
  let myList = new LinkedList<int>()
  let count = 3
  
  for i = 0 to 10
    myList.add(i)

  // act
  let first3 = myList.take(count)

  // assert
  first3.size().assertEquals(count)
  for i = 0 to count - 1
    first3.get(i).assertEquals(i)
