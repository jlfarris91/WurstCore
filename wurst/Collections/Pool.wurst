package Pool
import Vector
import ErrorHandling
import Math

public constant INVALID_POOL_HANDLE = poolHandle(-1, -1)

// ============================================================================
public tuple poolHandle(int id, int gen)

// ============================================================================
public function poolHandleToIndex(poolHandle poolHandle) returns int
  return poolHandle.gen * 10000 + poolHandle.id

// ============================================================================
public function poolHandleFromIndex(int index) returns poolHandle
  let id = index mod 10000
  let gen = ((index - id) / 10000).ceil()
  return poolHandle(id, gen)

// ============================================================================
public class Pool<T>
  private Vector<T> m_entries
  private Vector<int> m_generations
  private Vector<bool> m_availablity
  private int m_lastReservedIndex
  private int m_reservedCount

  // --------------------------------------------------------------------------
  construct(int capacity)
    m_entries = new Vector<T>(capacity)
    m_generations = new Vector<int>(capacity)
    m_availablity = new Vector<bool>(capacity)

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_entries
    destroy m_generations
    destroy m_availablity

  // --------------------------------------------------------------------------
  function getCapacity() returns int
    return m_entries.getCapacity()

  // --------------------------------------------------------------------------
  function getCount() returns int
    return m_entries.getCount()

  // --------------------------------------------------------------------------
  function clear()
    for i = 0 to m_entries.getCount() - 1
      // Make all entries available
      m_availablity.set(i, true)
      // Invalidate existing handles
      incrementGeneration(i)

  // --------------------------------------------------------------------------
  function reserve() returns poolHandle
    m_lastReservedIndex = findNextOpenSlot()
    setIsAvailable(m_lastReservedIndex, false)
    m_reservedCount++
    return poolHandle(m_lastReservedIndex, getGeneration(m_lastReservedIndex))

  // --------------------------------------------------------------------------
  function reserve(T element) returns poolHandle
    let poolHandle = reserve()
    set(poolHandle, element)
    return poolHandle

  // --------------------------------------------------------------------------
  function get(poolHandle poolHandle) returns T
    validateHandle(poolHandle)
    return m_entries.get(poolHandle.id)

  // --------------------------------------------------------------------------
  function set(poolHandle poolHandle, T element)
    validateHandle(poolHandle)
    m_entries.set(poolHandle.id, element)

  // --------------------------------------------------------------------------
  function release(poolHandle poolHandle)
    validateHandle(poolHandle)
    setIsAvailable(poolHandle.id, true)
    incrementGeneration(poolHandle.id)
    m_reservedCount--

  // --------------------------------------------------------------------------
  function iterator() returns PoolEnumerator<T>
    return new PoolEnumerator<T>(m_availablity, m_generations)

  // --------------------------------------------------------------------------
  function toVector() returns Vector<poolHandle>
    let vector = new Vector<poolHandle>(m_reservedCount)
    for i = 0 to m_entries.getCount() - 1
      if (not getIsAvailable(i))
        vector.add(poolHandle(i, getGeneration(i)))
    return vector

  // --------------------------------------------------------------------------
  function isHandleValid(poolHandle poolHandle) returns bool
    if (poolHandle.id < 0 or poolHandle.id >= m_entries.getCount())
      return false
    if (getGeneration(poolHandle.id) != poolHandle.gen)
      return false
    return true

  // --------------------------------------------------------------------------
  private function validateHandle(poolHandle poolHandle)
    if (not isHandleValid(poolHandle))
      error("Pool handle " + poolHandle.id.toString() + " is invalid")

  // --------------------------------------------------------------------------
  private function getIsAvailable(int index) returns bool
    return m_availablity.get(index)

  // --------------------------------------------------------------------------
  private function setIsAvailable(int index, bool available)
    m_availablity.set(index, available)

  // --------------------------------------------------------------------------
  private function getGeneration(int index) returns int
    return m_generations.get(index)

  // --------------------------------------------------------------------------
  private function incrementGeneration(int index)
    let currentGen = getGeneration(index)
    m_generations.set(index, currentGen + 1)

  // --------------------------------------------------------------------------
  private function findNextOpenSlot() returns int

    if (not m_entries.isEmpty() and m_reservedCount < m_entries.getCount())

      var index = m_lastReservedIndex

      // Maybe we're already on an empty slot
      if (getIsAvailable(index))
        return index

      let initialIndex = index
      index = incrementIndex(index)

      // Search for an open slot until we reach our initial pos
      while (index != initialIndex)
        if (getIsAvailable(index))
          return index
        index = incrementIndex(index)

    // No available slots, add another
    addEntry()
    return m_entries.getCount() - 1

  // --------------------------------------------------------------------------
  private function incrementIndex(int index) returns int
    let newIndex = wrap(index + 1, 0, m_entries.getCount() - 1)
    return newIndex

  // --------------------------------------------------------------------------
  private function addEntry()
    m_entries.add(0 castTo T)
    m_generations.add(0)
    m_availablity.add(true)

// ============================================================================
public class PoolEnumerator<T>
  private Vector<bool> m_availability
  private Vector<int> m_generations
  private int m_next

  // --------------------------------------------------------------------------
  construct (Vector<bool> availability, Vector<int> generations)
    m_availability = availability
    m_generations = generations
    reset()

  // --------------------------------------------------------------------------
  ondestroy
    m_availability = null
    m_generations = null

  // --------------------------------------------------------------------------
  function reset()
    m_next = -1
    findNextValidIndex()

  // --------------------------------------------------------------------------
  function hasNext() returns bool
    return m_next < m_availability.getCount()

  // --------------------------------------------------------------------------
  function next() returns poolHandle
    let current = m_next
    findNextValidIndex()
    return poolHandle(current, m_generations.get(current))

  // --------------------------------------------------------------------------
  function close()
    destroy this

  // --------------------------------------------------------------------------
  private function findNextValidIndex()
    m_next++
    while (m_next < m_availability.getCount() and m_availability.get(m_next))
      m_next++
        
