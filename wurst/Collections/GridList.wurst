package GridList
import HashMap
import LinkedList
import Grid
import Bounds
import ErrorHandling
import Enumerable
import Linq
import ErrorIf
import Selector

// ============================================================================
public class GridList<T> implements IGrid, IEnumerable<T>
  private Grid _grid
  private HashMap<int, GridBucket<T>> _cellToBucketMap
  private int _size

  // --------------------------------------------------------------------------
  construct (bounds bounds, int width, int height)
    _grid = new Grid(bounds, width, height)
    _cellToBucketMap = new HashMap<int, GridBucket<T>>()
    _size = 0
    updateBuckets()

  // --------------------------------------------------------------------------
  ondestroy
    destroyBuckets()
    destroy _cellToBucketMap
    destroy _grid

  // --------------------------------------------------------------------------
  function add(T data, vec2 pos)
    let cell = getCell(pos)
    if (cell == INVALID_CELL)
      error("Position is outside of the bounds of the grid")
    let bucket = getBucket(cell)
    bucket._items.add(data)
    print("Added item to bucket " + cell.toString())
    _size++

  // --------------------------------------------------------------------------
  function remove(T data) returns bool
    let w = getWidth()
    let h = getHeight()
    for r = 0 to h
      for c = 0 to w
        let bucket = getBucket(cell(r, c))
        if (bucket._items.remove(data))
          _size--
          return true
    return false

  // --------------------------------------------------------------------------
  function clear()
    let w = getWidth()
    let h = getHeight()
    for r = 0 to h
      for c = 0 to w
        let bucket = getBucket(cell(r, c))
        bucket._items.clear()
    _size = 0

  // --------------------------------------------------------------------------
  function size() returns int
    return _size

  // --------------------------------------------------------------------------
  function getElementsInRange(vec2 pos, real range, Vec2Selector<T> posSelector) returns IEnumerable<T>
    ErrorIf.argumentIsNull(posSelector, "posSelector")
    let area = _grid.getArea(pos, range)
    return new RangedEnumerable(this, area, false).where() (data) ->
      let dataPos = posSelector.select(data)
      return dataPos.distanceToSq(pos) < range * range

  // --------------------------------------------------------------------------
  function getBucket(cell cell) returns GridBucket<T>
    return _cellToBucketMap.get(getIndex(cell))

  // --------------------------------------------------------------------------
  private function updateBuckets()
    _grid.forEachCell() (int r, int c) ->
      createBucket(cell(r, c))
        
  // --------------------------------------------------------------------------
  private function destroyBuckets()
    _grid.forEachCell() (int r, int c) ->
      let index = getIndex(cell(r, c))
      destroy _cellToBucketMap.get(index)

  // --------------------------------------------------------------------------
  private function createBucket(cell cell)
    let index = getIndex(cell)
    let cellBounds = getCellBounds(cell)
    let bucket = new GridBucket<T>(cellBounds)
    _cellToBucketMap.put(index, bucket)
  
  // --------------------------------------------------------------------------
  override function getBounds() returns bounds
    return _grid.getBounds()

  // --------------------------------------------------------------------------
  override function getWidth() returns int
    return _grid.getWidth()

  // --------------------------------------------------------------------------
  override function getHeight() returns int
    return _grid.getHeight()

  // --------------------------------------------------------------------------
  override function getCell(vec2 pos) returns cell
    return _grid.getCell(pos)

  // --------------------------------------------------------------------------
  override function getIndex(cell cell) returns int
    return _grid.getIndex(cell)

  // --------------------------------------------------------------------------
  override function getCellBounds(cell cell) returns bounds
    return _grid.getCellBounds(cell)

  override function iterator() returns IEnumerator<T>
    return new GridListEnumerator<T>(this)

// ============================================================================
class GridBucket<T> implements IEnumerable<T>
  bounds _bounds
  LinkedList<T> _items

  // --------------------------------------------------------------------------
  construct(bounds bounds)
    _bounds = bounds
    _items = new LinkedList<T>()

  // --------------------------------------------------------------------------
  ondestroy
    destroy _items

  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return _items.iterator().asEnumerator()

// ============================================================================
class GridListEnumerator<T> implements IEnumerator<T>
  private GridList<T> _list
  private IEnumerator<T> _current
  private int _col
  private int _row
  
  // --------------------------------------------------------------------------
  construct(GridList<T> list)
    _list = list
    _col = 0
    _row = 0
    getNextBucket()

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    while (_current != null and not _current.hasNext())
      getNextBucket()
    return _current != null and _current.hasNext()

  // --------------------------------------------------------------------------
  override function next() returns T
    return _current.next()

  // --------------------------------------------------------------------------
  override function close()
    destroy this

  // --------------------------------------------------------------------------
  private function getNextBucket()

    if (_current != null)
      destroy _current
      _current = null

    _col++
    if (_col == _list.getWidth())
      _col = 0
      _row++
      if (_row == _list.getHeight())
        return

    _current = _list.getBucket(cell(_row, _col)).iterator()

// ============================================================================
class RangedEnumerable<T> implements IEnumerable<T>
  private GridList<T> _list
  private bool _ownsList
  private span _area

  // --------------------------------------------------------------------------
  construct(GridList<T> list, span area, bool ownsList)
    _list = list
    _ownsList = ownsList
    _area = area

  ondestroy
    if (_ownsList)
      destroy _list
    _list = null

  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new RangedEnumerator<T>(_list, _area)

// ============================================================================
class RangedEnumerator<T> implements IEnumerator<T>
  private GridList<T> _list
  private span _area
  private cell _current
  private LLIterator<T> _iterator
  private bool _initialized

  // --------------------------------------------------------------------------
  construct(GridList<T> list, span area)
    _list = list
    _area = area
    _initialized = false

  // --------------------------------------------------------------------------
  ondestroy
    if (_iterator != null)
      destroy _iterator
      _iterator = null

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    if (_iterator == null or not _iterator.hasNext())
      findNextIterator()
    return _iterator != null and _iterator.hasNext()

  // --------------------------------------------------------------------------
  override function next() returns T
    return _iterator.next()

  // --------------------------------------------------------------------------
  private function findNextIterator()
    
    if (_iterator != null)
      destroy _iterator
      _iterator = null

    if (not _initialized)
      _current = _area.min
      _initialized = true
      
    else
      _current.column++
      if (_current.column > _area.max.column)
        _current.row++
        _current.column = _area.min.column
        if (_current.row > _area.max.row)
          return
    
    _iterator = _list.getBucket(_current)._items.iterator()

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
class TestClass
  vec2 _pos
  string _data

  construct(vec2 pos, string data)
    _pos = pos
    _data = data

// ============================================================================
@test
function gridList_getElementsInRange_zeroRange()
  // arrange
  let min = vec2(0, 0)
  let max = vec2(100, 100)
  let gridList = new GridList<TestClass>(bounds(min, max), 10, 10)

  for r = 0 to 9
    for c = 0 to 9
      let pos = vec2(I2R(r), I2R(c)) * 10.0 + vec2(5, 5)
      let cell = cell(r, c)
      gridList.add(new TestClass(pos, cell.toString()), pos)

  // act
  var elements = gridList.getElementsInRange(vec2(50, 50), 0) (data) ->
    return data._pos

  // assert
  assertTrue(not elements.any())

// ============================================================================
@test
function gridList_getElementsInRange_zeroRange2()
  // arrange
  let min = vec2(0, 0)
  let max = vec2(100, 100)
  let gridList = new GridList<TestClass>(bounds(min, max), 10, 10)

  for r = 0 to 9
    for c = 0 to 9
      let pos = vec2(I2R(r), I2R(c)) * 10.0 + vec2(5, 5)
      let cell = cell(r, c)
      
      for i = 0 to 9
        gridList.add(new TestClass(pos, cell.toString() + " " + I2S(i)), pos)

  // act
  var elements = gridList.getElementsInRange(vec2(50, 50), 22) (data) ->
    return data._pos

  // assert
  elements.forEach() (TestClass a) ->
    print(a._data)