package Enumerable
import Func
import Action

import initlater LinkedList
import initlater HashList
import initlater Vector

// ============================================================================
public abstract class IEnumerator<T>
  abstract function hasNext() returns bool
  abstract function next() returns T
  abstract function close()

// ============================================================================
public abstract class IEnumerable<T>
  abstract function iterator() returns IEnumerator<T>
  abstract function close()

// ============================================================================
public class Enumerable

  // --------------------------------------------------------------------------
  static function empty<T>() returns IEnumerable<T>
    return new EmptyEnumerable<T>()

// ============================================================================
/** Creates a wrapper that can enumerate the source but will not destroy it when closed */
public function IEnumerable<T>.read<T>() returns IEnumerable<T>
  return new EnumerableAdapter<T>(this)

// ============================================================================
public function IEnumerable<T>.forEach<T>(Action1<T> action)
  let enumerator = this.iterator()
  while (enumerator.hasNext())
    action.call(enumerator.next())
  destroy enumerator

// ============================================================================
class EmptyEnumerable<T> extends IEnumerable<T>

  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new EmptyEnumerator<T>()

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
class EmptyEnumerator<T> extends IEnumerator<T>

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return false

  // --------------------------------------------------------------------------
  override function next() returns T
    return null

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
class EnumerableAdapter<T> extends IEnumerable<T>
  private IEnumerable<T> m_source

  // --------------------------------------------------------------------------
  construct (IEnumerable<T> source)
    m_source = source

  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new EnumeratorAdpater<T>(m_source.iterator())

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
class EnumeratorAdpater<T> extends IEnumerator<T>
  private IEnumerator<T> m_source

  // --------------------------------------------------------------------------
  construct(IEnumerator<T> source)
    m_source = source

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_source

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return false

  // --------------------------------------------------------------------------
  override function next() returns T
    return null

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
public function LinkedList<T>.enumerate<T>(bool owns) returns IEnumerable<T>
  return new LinkedListEnumerable<T>(this, owns)

// ============================================================================
public class LinkedListEnumerable<T> extends IEnumerable<T>
  private LinkedList<T> m_source
  private bool m_owns

  // --------------------------------------------------------------------------
  construct (LinkedList<T> source, bool owns)
    m_source = source
    m_owns = owns
  
  // --------------------------------------------------------------------------
  ondestroy
    if (m_owns)
      destroy m_source
  
  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new LinkedListEnumerator<T>(m_source.iterator(), m_owns)

  // --------------------------------------------------------------------------
  override function close()
    destroy this
  
// ============================================================================
public class LinkedListEnumerator<T> extends IEnumerator<T>
  private LLIterator<T> m_iterator
  private bool m_owns
  
  // --------------------------------------------------------------------------
  construct(LLIterator<T> iterator, bool owns)
    m_iterator = iterator
    m_owns = owns
  
  // --------------------------------------------------------------------------
  ondestroy
    if (m_owns)
      destroy m_iterator
  
  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_iterator.hasNext()
  
  // --------------------------------------------------------------------------
  override function next() returns T
    return m_iterator.next()

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
public function HashList<T>.enumerate<T>(bool owns) returns IEnumerable<T>
  return new HashListEnumerable<T>(this, owns)

// ============================================================================
public class HashListEnumerable<T> extends IEnumerable<T>
  private HashList<T> m_source
  private bool m_owns
  
  // --------------------------------------------------------------------------
  construct (HashList<T> source, bool owns)
    m_source = source
    m_owns = owns
  
  // --------------------------------------------------------------------------
  ondestroy
    if (m_owns)
      destroy m_source
  
  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new HashListEnumerator<T>(m_source.iterator(), m_owns)
  
  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
public class HashListEnumerator<T> extends IEnumerator<T>
  private HLIterator<T> m_iterator
  private bool m_owns
  
  // --------------------------------------------------------------------------
  construct(HLIterator<T> iterator, bool owns)
    m_iterator = iterator
    m_owns = owns
  
  // --------------------------------------------------------------------------
  ondestroy
    if (m_owns)
      destroy m_iterator
  
  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_iterator.hasNext()
  
  // --------------------------------------------------------------------------
  override function next() returns T
    return m_iterator.next()
  
  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
public function Vector<T>.enumerate<T>(bool owns) returns IEnumerable<T>
  return new VectorEnumerable<T>(this, owns)

// ============================================================================
public class VectorEnumerable<T> extends IEnumerable<T>
  private Vector<T> m_source
  private bool m_owns
  
  // --------------------------------------------------------------------------
  construct (Vector<T> source, bool owns)
    m_source = source
    m_owns = owns
  
  // --------------------------------------------------------------------------
  ondestroy
    if (m_owns)
      destroy m_source
  
  // --------------------------------------------------------------------------
  override function iterator() returns IEnumerator<T>
    return new VectorEnumerator<T>(m_source.iterator(), m_owns)
  
  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
public class VectorEnumerator<T> extends IEnumerator<T>
  private VectorIterator<T> m_iterator
  private bool m_owns
  
  // --------------------------------------------------------------------------
  construct(VectorIterator<T> iterator, bool owns)
    m_iterator = iterator
    m_owns = owns
  
  // --------------------------------------------------------------------------
  ondestroy
    if (m_owns)
      destroy m_iterator
  
  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_iterator.hasNext()
  
  // --------------------------------------------------------------------------
  override function next() returns T
    return m_iterator.next()

  // --------------------------------------------------------------------------
  override function close()
    destroy this

// ============================================================================
public class RangeEnumerator<T> extends IEnumerator<T>
  private Func1<int, T> m_iterator
  private int m_curr
  private int m_end
  
  // --------------------------------------------------------------------------
  construct(Func1<int, T> iterator, int startIndex, int endIndex)
    m_iterator = iterator
    m_curr = startIndex
    m_end = endIndex
  
  // --------------------------------------------------------------------------
  ondestroy
    destroy m_iterator
  
  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_curr < m_end
  
  // --------------------------------------------------------------------------
  override function next() returns T
    m_curr++
    return m_iterator.call(m_curr)

  // --------------------------------------------------------------------------
  override function close()
    destroy this