package Action
import LinkedList

// ============================================================================
public interface Action
  function call()

// ============================================================================
public interface Action1<TArg>
  function call(TArg arg)

// ============================================================================
public interface Action2<TArg1, TArg2>
  function call(TArg1 arg1, TArg2 arg2)

// ============================================================================
public interface Action3<TArg1, TArg2, TArg3>
  function call(TArg1 arg1, TArg2 arg2, TArg3 arg3)

// ============================================================================
public class MulticastAction implements Action
  private LinkedList<Action> m_invocationList

  // --------------------------------------------------------------------------
  construct()
    m_invocationList = new LinkedList<Action>()

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_invocationList

  // --------------------------------------------------------------------------
  function iterator() returns LLIterator<Action>
    return m_invocationList.iterator()

  // --------------------------------------------------------------------------
  function add(Action action) returns Action
    m_invocationList.add(action)
    return action

  // --------------------------------------------------------------------------
  function remove(Action action) returns bool
    return m_invocationList.remove(action)

  // --------------------------------------------------------------------------
  override function call()
    let invocations = m_invocationList.copy()
    for impl in invocations
      impl.call()
    destroy invocations

// ============================================================================
public class MulticastAction1<TArg1> implements Action1<TArg1>
  private LinkedList<Action1<TArg1>> m_invocationList

  // --------------------------------------------------------------------------
  construct()
    m_invocationList = new LinkedList<Action1<TArg1>>()

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_invocationList

  // --------------------------------------------------------------------------
  function iterator() returns LLIterator<Action1<TArg1>>
    return m_invocationList.iterator()

  // --------------------------------------------------------------------------
  function add(Action1<TArg1> action) returns Action1<TArg1>
    m_invocationList.add(action)
    return action

  // --------------------------------------------------------------------------
  function remove(Action1<TArg1> action) returns bool
    return m_invocationList.remove(action)

  // --------------------------------------------------------------------------
  override function call(TArg1 arg1)
    let invocations = m_invocationList.copy()
    for impl in invocations
      impl.call(arg1)
    destroy invocations

// ============================================================================
public class MulticastAction2<TArg1, TArg2> implements Action2<TArg1, TArg2>
  private LinkedList<Action2<TArg1, TArg2>> m_invocationList

  // --------------------------------------------------------------------------
  construct()
    m_invocationList = new LinkedList<Action2<TArg1, TArg2>>()

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_invocationList

  // --------------------------------------------------------------------------
  function iterator() returns LLIterator<Action2<TArg1, TArg2>>
    return m_invocationList.iterator()

  // --------------------------------------------------------------------------
  function add(Action2<TArg1, TArg2> action) returns Action2<TArg1, TArg2>
    m_invocationList.add(action)
    return action

  // --------------------------------------------------------------------------
  function remove(Action2<TArg1, TArg2> action) returns bool
    return m_invocationList.remove(action)

  // --------------------------------------------------------------------------
  override function call(TArg1 arg1, TArg2 arg2)
    let invocations = m_invocationList.copy()
    for impl in invocations
      impl.call(arg1, arg2)
    destroy invocations

// ============================================================================
public class MulticastAction3<TArg1, TArg2, TArg3> implements Action3<TArg1, TArg2, TArg3>
  private LinkedList<Action3<TArg1, TArg2, TArg3>> m_invocationList

  // --------------------------------------------------------------------------
  construct()
    m_invocationList = new LinkedList<Action3<TArg1, TArg2, TArg3>>()

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_invocationList

  // --------------------------------------------------------------------------
  function iterator() returns LLIterator<Action3<TArg1, TArg2, TArg3>>
    return m_invocationList.iterator()

  // --------------------------------------------------------------------------
  function add(Action3<TArg1, TArg2, TArg3> action) returns Action3<TArg1, TArg2, TArg3>
    m_invocationList.add(action)
    return action

  // --------------------------------------------------------------------------
  function remove(Action3<TArg1, TArg2, TArg3> action) returns bool
    return m_invocationList.remove(action)

  // --------------------------------------------------------------------------
  override function call(TArg1 arg1, TArg2 arg2, TArg3 arg3)
    let invocations = m_invocationList.copy()
    for impl in invocations
      impl.call(arg1, arg2, arg3)
    destroy invocations