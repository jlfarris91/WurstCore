package Notifications
import RealtimeUpdate
import Layout
import LinkedList
import ErrorHandling
import Events
import Math
import LinkedListExtensions
import Command
import Observable
import ClosureTimers
import ClosureFrames
import Action
import IProgress
import HashMap
import FramehandleExtensions
import FullscreenFrame
import Icons
import TimerUtils
import Trace
import NativeFrame
import Vector

/*

  let notificationFrameFactory = new NotificationFrameFactory()
  ..registerFactory(Notification.typeId, () -> new SimpleTextNotificationFrame(createFrame("SimpleNotification")))
  ..registerFactory(ActionNotification.typeId, () -> new ActionNotificationFrame(createFrame("ActionNotification")))
  ..registerFactory(ChoiceNotification.typeId, () -> new ChoiceNotificationFrame(createFrame("ChoiceNotification")))
  ..registerFactory(LootingNotification.typeId, () -> new SimpleTextNotificationFrame(createFrame("SimpleNotification")))

  ...

  let simpleNotification = new Notification()
  ..setMessage("Hello world!")
  ..setIcon(Icons.bTNFootman)

  NotificationManager.getInstance().show(simpleNotification, players[0])

*/

@configurable public constant real DEFAULT_NOTIFICATION_DURATION = 15.0
@configurable public constant string DEFAULT_NOTIFICATION_ICON_PATH = Icons.bTNScroll

constant rectr NOTIFICATION_AREA = rectr(0.01, 0.2, 0.1666, 0.3)
constant real NOTIFICATION_SPACING = 0.0055
constant real NOTIFICATION_FADE_DURATION = 1.0
constant real NOTIFICATION_TRAILING_DIST = 0.05
constant RealtimeUpdatePriority NOTIFICATION_UPDATE_PRIORITY = RealtimeUpdatePriority.Realtime

int g_notificationIdCounter = 0

// ============================================================================
public function notifyPlayer(player p, string message)
  notifyPlayer(p, message, DEFAULT_NOTIFICATION_ICON_PATH)

// ============================================================================
public function notifyPlayer(player p, string message, string iconPath)
  notifyPlayer(p, message, iconPath, null)

// ============================================================================
public function notifyPlayer(player p, string message, string iconPath, CommandExecuteAction onClick)

  if (not p.isIngame())
    return

  let notification = new Notification()
  ..setMessage(message)
  ..setIconPath(iconPath)
  
  if (onClick != null)
    notification.setClickCommand(new RoutedCommand(onClick))
  
  notification.show(p)

// ============================================================================
public function notifyAllPlayers(string message)
  notifyAllPlayers(message, DEFAULT_NOTIFICATION_ICON_PATH)

// ============================================================================
public function notifyAllPlayers(string message, string iconPath)
  for i = 0 to bj_MAX_PLAYER_SLOTS-1
    if (players[i].isIngame())
      notifyPlayer(players[i], message, iconPath)

// ============================================================================
class QueuedNotification
  Notification notification
  player forPlayer
  construct(Notification notification, player forPlayer)
    this.notification = notification
    this.forPlayer = forPlayer

// ============================================================================
public class NotificationManager implements IRealtimeListener

  static constant NotificationFrameFactory notificationFrameFactory = new NotificationFrameFactory()
  static NotificationManager g_instance

  private LinkedList<NotificationSlot> m_notificationSlots
  private framehandle m_notificationArea
  private LinkedList<QueuedNotification> m_queuedNotifications
  private int m_needsUpdate
  private bool m_calculatingSlotPositions
  private rectr array[24] m_slotPositions

  // --------------------------------------------------------------------------
  construct ()
    m_notificationSlots = new LinkedList<NotificationSlot>()
    m_queuedNotifications = new LinkedList<QueuedNotification>()

    nullTimer(() -> start())

  // --------------------------------------------------------------------------
  ondestroy
    this.unregisterForRealtimeUpdate()

    for slot in m_notificationSlots
      destroy slot
    destroy m_notificationSlots

    if (m_queuedNotifications != null)
      destroy m_queuedNotifications
      m_queuedNotifications = null

    if (m_notificationArea != null)
      m_notificationArea.hide()
      m_notificationArea.remove()

  // --------------------------------------------------------------------------
  static function getInstance() returns NotificationManager
    if (g_instance == null)
      g_instance = new NotificationManager()
    return g_instance

  // --------------------------------------------------------------------------
  static function nextNotificationId() returns int
    g_notificationIdCounter++
    return g_notificationIdCounter

  // --------------------------------------------------------------------------
  private function start()

    m_notificationArea = createFrame("NotificationAreaTemplate", CONSOLE_UI_BACKDROP, 0, 0)
    ..setPoint(FRAMEPOINT_TOPLEFT, FULLSCREEN_FRAME, FRAMEPOINT_BOTTOMLEFT, NOTIFICATION_AREA.topLeft())
    ..setSize(NOTIFICATION_AREA.width, NOTIFICATION_AREA.height)

    while not m_queuedNotifications.isEmpty()
      let queuedNotification = m_queuedNotifications.pop()
      show(queuedNotification.notification, queuedNotification.forPlayer)
      destroy queuedNotification
    destroy m_queuedNotifications

  // --------------------------------------------------------------------------
  function show(Notification notification, player forPlayer) returns bool

    if (m_notificationArea == null)
      m_queuedNotifications.add(new QueuedNotification(notification, forPlayer))
      return true

    let frame = notificationFrameFactory.createFrame(notification.typeId)

    if (frame == null)
      error("Unable to create frame for notification with type id " + notification.typeId.toString())

    let frameHeight = frame.getFrameHandle().getHeight()
    if (frameHeight == 0)
      error("Notification frame must specify a height")

    rectr startArea = rectr(0.0, 0.0, m_notificationArea.getWidth(), frameHeight)

    if (not m_notificationSlots.isEmpty())
      startArea = m_notificationSlots.getLast().m_currentArea
      startArea.y += startArea.height + NOTIFICATION_SPACING

    startArea.y += NOTIFICATION_TRAILING_DIST

    let notificationSlot = new NotificationSlot(this, forPlayer, notification, frame)
    notificationSlot.m_currentArea = startArea
    notificationSlot.setTargetAlpha(1.0)

    frame.getFrameHandle()
    ..setParent(m_notificationArea)
    ..setAlpha(0)
    ..hide()
    ..show(forPlayer)
    
    frame.setNotification(notification)

    m_notificationSlots.add(notificationSlot)

    notification.onShow()

    onVisualsInvalidate()

    return true

  // --------------------------------------------------------------------------
  function remove(Notification notification) returns bool
    NotificationSlot removed = null

    let iter = m_notificationSlots.iterator()
    while iter.hasNext()
      let current = iter.next()
      if (current.m_notification == notification)
        removed = current
        iter.remove()
        break
    iter.close()

    if (removed != null)
      destroy removed
      onVisualsInvalidate()
      return true

    return false

  // --------------------------------------------------------------------------
  function remove(Notification notification, player forPlayer) returns bool
    NotificationSlot removed = null

    let iter = m_notificationSlots.iterator()
    while iter.hasNext()
      let current = iter.next()
      if (current.m_player == forPlayer and current.m_notification == notification)
        removed = current
        iter.remove()
        break
    iter.close()

    if (removed != null)
      destroy removed
      onVisualsInvalidate()
      return true

    return false

  // --------------------------------------------------------------------------
  function clear(player forPlayer)
    var anyRemoved = false

    let iter = m_notificationSlots.iterator()
    while iter.hasNext()
      let current = iter.next()
      if (current.m_player == forPlayer and current.m_notification.canClose())
        iter.remove()
        destroy current
        anyRemoved = true
    iter.close()

    if (anyRemoved)
      onVisualsInvalidate()

  // --------------------------------------------------------------------------
  override protected function realtimeUpdate(real dt)
    Trace.trace("NotificationManager.update")
    for notification in m_notificationSlots
      notification.update(dt)

  // --------------------------------------------------------------------------
  protected function onVisualsInvalidate()
    if (not m_calculatingSlotPositions)
      m_calculatingSlotPositions = true
      nullTimer() () -> 
        calculateSlotPositions()
        m_calculatingSlotPositions = false

  // --------------------------------------------------------------------------
  private function calculateSlotPositions()

    for i = 0 to 23
      m_slotPositions[i] = rectr(0, 0, NOTIFICATION_AREA.width, 0)

    for notification in m_notificationSlots
      let pid = notification.m_player.getId()
      m_slotPositions[pid].height = notification.getFrameHeight()
      notification.setTargetArea(m_slotPositions[pid])
      m_slotPositions[pid].y += m_slotPositions[pid].height + NOTIFICATION_SPACING

  // --------------------------------------------------------------------------
  protected function slotNeedsUpdate(bool value)
    m_needsUpdate += (value ? 1 : -1)
    if (m_needsUpdate == 0)
      this.unregisterForRealtimeUpdate()
    else if (m_needsUpdate == 1)
      this.registerForRealtimeUpdate(NOTIFICATION_UPDATE_PRIORITY)      

// ============================================================================
class NotificationSlot
  private NotificationManager m_manager = null
  protected player m_player = null
  protected Notification m_notification = null
  protected NotificationFrame m_notificationFrame = null
  protected rectr m_currentArea = ZERORECTR
  private rectr m_targetArea = ZERORECTR
  private real m_areaYVelocity = 0.0
  protected real m_currentAlpha = 0.0
  private real m_targetAlpha = 0.0
  private _handle m_onClosedCallback = INVALID_HANDLE
  private _handle m_frameInvalidatedCallback = INVALID_HANDLE
  private bool m_needsUpdate = false

  // --------------------------------------------------------------------------
  construct (NotificationManager manager, player p, Notification notification, NotificationFrame notificationFrame)
    m_manager = manager
    m_player = p
    m_notification = notification
    m_notificationFrame = notificationFrame

    m_onClosedCallback = notification.onClosed().register() ->
      manager.remove(m_notification, m_player)

    m_frameInvalidatedCallback = notificationFrame.onFrameInvalidated().register() -> 
      manager.onVisualsInvalidate()

  // --------------------------------------------------------------------------
  ondestroy

    if (m_onClosedCallback != INVALID_HANDLE)
      m_notification.onClosed().unregister(m_onClosedCallback)
      m_onClosedCallback = INVALID_HANDLE

    if (m_frameInvalidatedCallback != INVALID_HANDLE)
      m_notificationFrame.onFrameInvalidated().unregister(m_frameInvalidatedCallback)
      m_frameInvalidatedCallback = INVALID_HANDLE

    m_notificationFrame.release()
    destroy m_notification

    if (m_needsUpdate)
      m_manager.slotNeedsUpdate(false)

  // --------------------------------------------------------------------------
  function update(real dt)

    if (not m_needsUpdate)
      return

    Trace.trace("NotificationSlot.update")

    let smoothDampResult = smoothDamp(m_currentArea.y, m_targetArea.y, m_areaYVelocity, 0.1, 0.2, dt)
    m_currentArea.y = smoothDampResult.value
    m_areaYVelocity = smoothDampResult.vel

    let frame = m_notificationFrame.getFrameHandle()

    frame.clearAllPoints()
    frame.setPoint(FRAMEPOINT_TOPLEFT, frame.getParent(), FRAMEPOINT_TOPLEFT, m_currentArea.x, -m_currentArea.y)
    frame.setWidth(m_currentArea.width)

    let alphaDelta = m_targetAlpha - m_currentAlpha
    if (alphaDelta.abs() > 0.001)
      m_currentAlpha += alphaDelta.sign() * min(alphaDelta, dt / NOTIFICATION_FADE_DURATION)
      frame.setAlpha((m_currentAlpha * 255).floor())
    else
      m_currentAlpha = m_targetAlpha
      frame.setAlpha((m_currentAlpha * 255).floor())

    if (m_currentAlpha.fuzzyEquals(m_targetAlpha) and
        m_currentArea.y.fuzzyEquals(m_targetArea.y))
      m_manager.slotNeedsUpdate(false)
      m_needsUpdate = false

  // --------------------------------------------------------------------------
  function setTargetArea(rectr value)
    if (m_targetArea != value)
      m_targetArea = value
      if (not m_needsUpdate)
        m_manager.slotNeedsUpdate(true)
        m_needsUpdate = true

  // --------------------------------------------------------------------------
  function setTargetAlpha(real value)
    if (m_targetAlpha != value)
      m_targetAlpha = value
      if (not m_needsUpdate)
        m_manager.slotNeedsUpdate(true)
        m_needsUpdate = true

  // --------------------------------------------------------------------------
  function getFrameHeight() returns real
    return m_currentArea.height

// ============================================================================
public interface INotificationFrameFactory
  function createFrame(int notificationTypeId) returns NotificationFrame

// ============================================================================
public interface NotificationFrameFactoryFunc
  function createFrame() returns NotificationFrame

// ============================================================================
public class NotificationFrameFactory implements INotificationFrameFactory
  private IterableMap<int, NotificationFramePool> m_pools

  // --------------------------------------------------------------------------
  construct()
    m_pools = new IterableMap<int, NotificationFramePool>()

  // --------------------------------------------------------------------------
  ondestroy

    for typeId in m_pools
      destroy m_pools.get(typeId)
    destroy m_pools

  // ============================================================================
  function registerFactory(int notificationTypeId, NotificationFrameFactoryFunc factoryFunc)
    let existingPool = m_pools.get(notificationTypeId)
    if (existingPool != null)
      destroy existingPool
    m_pools.put(notificationTypeId, new NotificationFramePool(factoryFunc))

  // --------------------------------------------------------------------------
  override function createFrame(int notificationTypeId) returns NotificationFrame
    let existingFactory = m_pools.get(notificationTypeId)
    return existingFactory != null ? existingFactory.getFrame() : null

// ============================================================================
public class Notification
  private int m_id = -1
  private bool m_closed = false
  private ICommand m_closeCommand = null
  private ICommand m_clickCommand = null
  private ICommand m_doubleClickCommand = null
  private Event m_onCloseEvent = null
  private CallbackSingle m_closeTimer = null
  private string m_iconPath = ""
  private string m_message = ""
  private bool m_showTimeRemaining = false
  private real m_duration = 0.0

  use Observable

  // --------------------------------------------------------------------------
  construct()
    __construct(NotificationManager.nextNotificationId(), DEFAULT_NOTIFICATION_DURATION)

  // --------------------------------------------------------------------------
  construct(int id)
    __construct(id, DEFAULT_NOTIFICATION_DURATION)

  // --------------------------------------------------------------------------
  construct(real duration)
    __construct(NotificationManager.nextNotificationId(), duration)

  // --------------------------------------------------------------------------
  construct(int id, real duration)
    __construct(id, duration)

  // --------------------------------------------------------------------------
  private function __construct(int id, real duration)
    m_id = id
    m_duration = duration
    m_closeCommand = new RoutedCommand(() -> close(), () -> canClose())
    m_showTimeRemaining = duration > 0.0

  // --------------------------------------------------------------------------
  ondestroy

    if (m_closeCommand != null)
      destroy m_closeCommand
      m_closeCommand = null

    if (m_clickCommand != null)
      destroy m_clickCommand
      m_clickCommand = null

    if (m_doubleClickCommand != null)
      destroy m_doubleClickCommand
      m_doubleClickCommand = null

    if (m_onCloseEvent != null)
      destroy m_onCloseEvent
      m_onCloseEvent = null

    if (m_closeTimer != null)
      destroy m_closeTimer
      m_closeTimer = null

  // --------------------------------------------------------------------------
  function getId() returns int
    return m_id

  // --------------------------------------------------------------------------
  function canClose() returns bool
    return true

  // --------------------------------------------------------------------------
  function getCloseCommand() returns ICommand
    return m_closeCommand

  // --------------------------------------------------------------------------
  function setCloseCommand(ICommand value)
    if (m_closeCommand != value)
      if (m_closeCommand != null)
        destroy m_closeCommand
      m_closeCommand = value
      raisePropertyChangedEvent("closeCommand")

  // --------------------------------------------------------------------------
  function getClickCommand() returns ICommand
    return m_clickCommand

  // --------------------------------------------------------------------------
  function setClickCommand(ICommand value)
    if (m_clickCommand != value)
      if (m_clickCommand != null)
        destroy m_clickCommand
      m_clickCommand = value
      raisePropertyChangedEvent("clickCommand")

  // --------------------------------------------------------------------------
  function setDoubleClickCommand(ICommand value)
    if (m_doubleClickCommand != value)
      if (m_doubleClickCommand != null)
        destroy m_doubleClickCommand
      m_doubleClickCommand = value
      raisePropertyChangedEvent("doubleClickCommand")

  // --------------------------------------------------------------------------
  function getDoubleClickCommand() returns ICommand
    return m_doubleClickCommand

  // --------------------------------------------------------------------------
  function getProgress() returns IProgress
    return null

  // --------------------------------------------------------------------------
  function getIconPath() returns string
    return m_iconPath

  // --------------------------------------------------------------------------
  function setIconPath(string value)
    if (m_iconPath != value)
      m_iconPath = value
      raisePropertyChangedEvent("iconPath")

  // --------------------------------------------------------------------------
  function setShowTimeRemaining(bool value)
    if (m_showTimeRemaining != value)
      m_showTimeRemaining = value
      raisePropertyChangedEvent("showTimeRemaining")

  // --------------------------------------------------------------------------
  function getShowTimeRemaining() returns bool
    return m_showTimeRemaining

  // --------------------------------------------------------------------------
  function getTimeRemaining() returns real
    return m_closeTimer != null ? m_closeTimer.getRemainingSeconds() : 0

  // --------------------------------------------------------------------------
  function getMessage() returns string
    return m_message

  // --------------------------------------------------------------------------
  function setMessage(string value)
    if (m_message != value)
      m_message = value
      raisePropertyChangedEvent("message")

  // --------------------------------------------------------------------------
  function onClosed() returns IEvent
    if (m_onCloseEvent == null)
      m_onCloseEvent = new Event()
    return m_onCloseEvent

  // --------------------------------------------------------------------------
  protected function onShow()
    
    if (m_duration > 0.0)
      m_closeTimer = doAfter(m_duration) () ->
        m_closeTimer = null
        close()

  // --------------------------------------------------------------------------
  function close()

    if (m_closed)
      return

    m_closed = true
    
    if (m_onCloseEvent != null)
      m_onCloseEvent.call()

  // --------------------------------------------------------------------------
  function show(player forPlayer) returns bool
    return NotificationManager.getInstance().show(this, forPlayer)

// ============================================================================
public interface NotificationFrame
  function getFrameHandle() returns framehandle
  function getNotification() returns Notification
  function setNotification(Notification value)
  function onFrameInvalidated() returns IEvent

// ============================================================================
public abstract class BaseNotificationFrame implements NotificationFrame
  protected framehandle m_frame = null
  protected Notification m_notification = null
  private Event m_frameInvalidatedEvent = null

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    m_frame = frame

  // --------------------------------------------------------------------------
  ondestroy

    if (m_frameInvalidatedEvent != null)
      destroy m_frameInvalidatedEvent
      m_frameInvalidatedEvent = null

    m_frame.release()
    m_frame = null

  // --------------------------------------------------------------------------
  override function getNotification() returns Notification
    return m_notification

  // --------------------------------------------------------------------------
  override function setNotification(Notification value)
    if (m_notification != value)
      let oldNotification = m_notification
      m_notification = value
      onNotificationChanged(oldNotification, value)

  // --------------------------------------------------------------------------
  override function onFrameInvalidated() returns IEvent
    if (m_frameInvalidatedEvent == null)
      m_frameInvalidatedEvent = new Event()
    return m_frameInvalidatedEvent

  // --------------------------------------------------------------------------
  protected function raiseFrameInvalidated()
    if (m_frameInvalidatedEvent != null)
      m_frameInvalidatedEvent.call()

  // --------------------------------------------------------------------------
  protected function onNotificationChanged(Notification _oldNotification, Notification _newNotification)
    skip

  // --------------------------------------------------------------------------
  protected function updateFrame()
    Trace.trace("NotificationFrame.update")

// ============================================================================
public class SimpleNotificationFrame extends BaseNotificationFrame
  protected framehandle m_iconFrame
  protected framehandle m_closeButtonFrame
  protected framehandle m_bodyFrame
  protected framehandle m_timeRemainingFrame
  protected framehandle m_progressBar
  private _handle m_propertyChangedCallback = INVALID_HANDLE
  private CallbackPeriodic m_updateTimeRemainingCallback = null
  private FrameHandleListener m_closeButtonClickHandler = null
  private FrameHandleListener m_frameClickHandler = null
  private IProgress m_progress = null
  private _handle m_progressChangedHandler = INVALID_HANDLE
  private timer m_doubleClickTimer = null

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    super(frame)

    m_iconFrame = getFrame("IconFrame")
    m_bodyFrame = getFrame("BodyFrame")
    m_timeRemainingFrame = getFrame("TimeRemaining")
    m_progressBar = getFrame("ProgressBar")

    m_closeButtonFrame = getFrame("CloseButton")
    m_closeButtonClickHandler = m_closeButtonFrame.onClick(() -> onCloseButtonClicked())

    m_frameClickHandler = frame.onClick(() -> onFrameClicked())

    m_doubleClickTimer = getTimer()

  // --------------------------------------------------------------------------
  ondestroy

    unregisterProgressEventHandlers()

    if (m_updateTimeRemainingCallback != null)
      destroy m_updateTimeRemainingCallback
      m_updateTimeRemainingCallback = null

    if (m_closeButtonClickHandler != null)
      destroy m_closeButtonClickHandler
      m_closeButtonClickHandler = null

    if (m_frameClickHandler != null)
      destroy m_frameClickHandler
      m_frameClickHandler = null

    m_doubleClickTimer.release()

  // --------------------------------------------------------------------------
  override function getFrameHandle() returns framehandle
    return m_frame

  // --------------------------------------------------------------------------
  override protected function onNotificationChanged(Notification oldNotification, Notification newNotification)

    if (oldNotification != null)
      oldNotification.onPropertyChanged().unregister(m_propertyChangedCallback)
      m_propertyChangedCallback = INVALID_HANDLE

    if (newNotification != null)
      m_propertyChangedCallback = newNotification.onPropertyChanged()
        .register((sender, arg) -> onNotificationPropertyChanged(sender, arg))

    m_notification = newNotification

    unregisterProgressEventHandlers()
    m_progress = null

    if (newNotification != null)
      m_progress = newNotification.getProgress()

    registerProgressEventHandlers()

    updateTimeRemainingFrame()

    updateShowTimeRemainingTimer()

    updateFrame()

  // --------------------------------------------------------------------------
  protected function onNotificationPropertyChanged(Notification _sender, string propertyName)

    updateFrame()

    if (propertyName == "showTimeRemaining")
      updateShowTimeRemainingTimer()

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()
    if (m_iconFrame != null)
      let iconPath = m_notification != null ? m_notification.getIconPath() : DEFAULT_NOTIFICATION_ICON_PATH
      m_iconFrame.setTexture(iconPath, 0, true)

    if (m_closeButtonFrame != null)
      let closeCommand = m_notification != null ? m_notification.getCloseCommand() : null
      let val = closeCommand != null and closeCommand.canExecute()
      m_closeButtonFrame.setVisible(val)
    
    let clickCommand = m_notification != null ? m_notification.getClickCommand() : null
    m_frame.setEnabled(clickCommand != null and clickCommand.canExecute())

    if (m_progressBar != null)
      m_progressBar.setVisible(m_progress != null)
      updateProgressBar()

  // --------------------------------------------------------------------------
  private function updateTimeRemainingFrame()
    if (m_timeRemainingFrame == null)
      return

    let showTimeRemaining = m_notification != null and m_notification.getShowTimeRemaining()    
    
    m_timeRemainingFrame.setVisible(showTimeRemaining)
    
    if (showTimeRemaining)
      m_timeRemainingFrame.setText(m_notification.getTimeRemaining().round().toString() + "s")

  // --------------------------------------------------------------------------
  private function onCloseButtonClicked()
    m_closeButtonFrame.clearFocus()

    if (m_notification == null)
      return

    let closeCommand = m_notification.getCloseCommand()
    if (closeCommand == null or not closeCommand.canExecute())
      return

    closeCommand.execute()

  // --------------------------------------------------------------------------
  private function onFrameClicked()
    getFrameHandle().clearFocus()

    if (m_notification == null)
      return

    if (m_doubleClickTimer.getRemaining() > 0)
    //{
      let doubleClickCommand = m_notification.getDoubleClickCommand()
      if (doubleClickCommand != null and doubleClickCommand.canExecute())
        doubleClickCommand.execute()
        return
    //}

    let clickCommand = m_notification.getClickCommand()
    if (clickCommand == null or not clickCommand.canExecute())
      return

    clickCommand.execute()
    m_doubleClickTimer.start(1.0, null)

  // --------------------------------------------------------------------------
  private function updateShowTimeRemainingTimer()
    
    if (m_updateTimeRemainingCallback != null)
      destroy m_updateTimeRemainingCallback
      m_updateTimeRemainingCallback = null

    if (m_notification != null and m_notification.getShowTimeRemaining())
      m_updateTimeRemainingCallback = doPeriodically(1.0, cb -> updateTimeRemainingFrame())    

  // --------------------------------------------------------------------------
  private function registerProgressEventHandlers()
    if (m_progress != null)
      m_progressChangedHandler = m_progress.onProgressChanged().register((_) -> updateProgressBar())

  // --------------------------------------------------------------------------
  private function unregisterProgressEventHandlers()
    if (m_progress != null)
      m_progress.onProgressChanged().unregister(m_progressChangedHandler)
      m_progressChangedHandler = INVALID_HANDLE

  // --------------------------------------------------------------------------
  private function updateProgressBar()
    if (m_progress != null and m_progressBar != null)
      let progress = clamp01(m_progress.getProgress())
      let totalWidth = getFrameHandle().getWidth() - 0.006
      m_progressBar.setWidth(totalWidth * progress)
      m_progressBar.setVertexColor(colorA(255, 204, 0, 100))

// ============================================================================
public class TextSimpleNotificationFrame extends SimpleNotificationFrame
  private framehandle m_textFrame

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    super(frame)

    m_textFrame = createFrame("NotificationTextTemplate")
    ..setParent(m_bodyFrame)
    ..setAllPoints(m_bodyFrame)
    ..show()

  // --------------------------------------------------------------------------
  ondestroy
    m_textFrame.release()

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()

    let text = m_notification != null ? m_notification.getMessage() : ""
    m_textFrame.setText(text)

// ============================================================================
public class ActionNotification extends Notification
  private ICommand m_activateCommand
  private Action m_action

  // --------------------------------------------------------------------------
  construct(Action action)
    super()
    __construct(action)

  // --------------------------------------------------------------------------
  construct(int id, Action action)
    super(id)
    __construct(action)

  // --------------------------------------------------------------------------
  construct(real duration, Action action)
    super(duration)
    __construct(action)

  // --------------------------------------------------------------------------
  construct(int id, real duration, Action action)
    super(id, duration)
    __construct(action)

  // --------------------------------------------------------------------------
  private function __construct(Action action)

    m_action = action.acquire()
    
    m_activateCommand = new RoutedCommand() () ->
      m_action.call()
      close()

  // --------------------------------------------------------------------------
  ondestroy
    m_action.release()
    destroy m_activateCommand

  // --------------------------------------------------------------------------
  function getActivateCommand() returns ICommand
    return m_activateCommand

// ============================================================================
public class ActionNotificationFrame extends SimpleNotificationFrame
  private framehandle m_activateButtonFrame
  private FrameHandleListener m_clickHandler = null

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    super(frame)

    m_activateButtonFrame = getFrame("ActivateButton")
    m_clickHandler = m_activateButtonFrame.onClick(() -> onActivateButtonClicked())

  // --------------------------------------------------------------------------
  ondestroy

    if (m_clickHandler != null)
      destroy m_clickHandler
      m_clickHandler = null

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()

    let actionNotification = m_notification castTo ActionNotification

    var enabled = true
    if (actionNotification != null)
      let command = actionNotification.getActivateCommand()
      enabled = command != null and command.canExecute()
    m_activateButtonFrame.setEnabled(enabled)

  // --------------------------------------------------------------------------
  private function onActivateButtonClicked()
    m_activateButtonFrame.clearFocus()

    let actionNotification = m_notification castTo ActionNotification
    if (actionNotification == null)
      return
    
    let command = actionNotification.getActivateCommand()
    if (command == null or not command.canExecute())
      return

    command.execute()

// ============================================================================
public class TextActionNotificationFrame extends ActionNotificationFrame
  private framehandle m_textFrame

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    super(frame)

    m_textFrame = createFrame("NotificationTextTemplate")
    ..setParent(m_bodyFrame)
    ..setAllPoints(m_bodyFrame)
    ..show()

  // --------------------------------------------------------------------------
  ondestroy
    m_textFrame.release()

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()

    let text = m_notification != null ? m_notification.getMessage() : ""
    m_textFrame.setText(text)

// ============================================================================
public class ChoiceNotification extends Notification
  private ICommand1<bool> m_choiceCommand
  private Action1<bool> m_action

  // --------------------------------------------------------------------------
  construct(int id, Action1<bool> action)
    super(id, 0)
    m_action = action.acquire()
    
    m_choiceCommand = new RoutedCommand1<bool>() (bool value) ->
      m_action.call(value)
      close()

  // --------------------------------------------------------------------------
  construct(int id, real duration, Action1<bool> action)
    super(id, duration)
    m_action = action.acquire()
    
    m_choiceCommand = new RoutedCommand1<bool>() (bool value) ->
      m_action.call(value)
      close()

  // --------------------------------------------------------------------------
  ondestroy
    m_action.release()
    destroy m_choiceCommand

  // --------------------------------------------------------------------------
  function getChoiceCommand() returns ICommand1<bool>
    return m_choiceCommand

// ============================================================================
public class ChoiceNotificationFrame extends SimpleNotificationFrame
  private framehandle m_yesButtonFrame
  private framehandle m_noButtonFrame
  private FrameHandleListener m_yesClickHandler = null
  private FrameHandleListener m_noClickHandler = null

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    super(frame)

    m_yesButtonFrame = getFrame("YesButton")
    m_yesClickHandler = m_yesButtonFrame.onClick(() -> onChoiceButtonClicked(true))

    m_noButtonFrame = getFrame("NoButton")
    m_noClickHandler = m_noButtonFrame.onClick(() -> onChoiceButtonClicked(false))

  // --------------------------------------------------------------------------
  ondestroy

    if (m_noClickHandler != null)
      destroy m_noClickHandler
      m_noClickHandler = null

    if (m_yesClickHandler != null)
      destroy m_yesClickHandler
      m_yesClickHandler = null

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()

    let choiceNotification = m_notification castTo ChoiceNotification

    var yesEnabled = true
    if (choiceNotification != null)
      let command = choiceNotification.getChoiceCommand()
      yesEnabled = command != null and command.canExecute(true)
    m_yesButtonFrame.setEnabled(yesEnabled)

    var noEnabled = true
    if (choiceNotification != null)
      let command = choiceNotification.getChoiceCommand()
      noEnabled = command != null and command.canExecute(false)
    m_noButtonFrame.setEnabled(noEnabled)

  // --------------------------------------------------------------------------
  private function onChoiceButtonClicked(bool value)
    m_yesButtonFrame.clearFocus()
    m_noButtonFrame.clearFocus()

    let choiceNotification = m_notification castTo ChoiceNotification
    if (choiceNotification == null)
      return
    
    let command = choiceNotification.getChoiceCommand()
    if (command == null or not command.canExecute(value))
      return

    command.execute(value)

// ============================================================================
public class TextChoiceNotificationFrame extends ChoiceNotificationFrame
  private framehandle m_textFrame

  // --------------------------------------------------------------------------
  construct (framehandle frame)
    super(frame)

    m_textFrame = createFrame("NotificationTextTemplate")
    ..setParent(m_bodyFrame)
    ..setAllPoints(m_bodyFrame)
    ..show()

  // --------------------------------------------------------------------------
  ondestroy
    m_textFrame.release()

  // --------------------------------------------------------------------------
  override protected function updateFrame()
    super.updateFrame()

    let text = m_notification != null ? m_notification.getMessage() : ""
    m_textFrame.setText(text)

HashMap<NotificationFrame, NotificationFramePool> g_frameToPool

// ============================================================================
public class NotificationFramePool
  private NotificationFrameFactoryFunc m_factoryFunc
  private Vector<NotificationFrame> m_freeList

  // --------------------------------------------------------------------------
  construct(NotificationFrameFactoryFunc factoryFunc)
    m_factoryFunc = factoryFunc
    m_freeList = new Vector<NotificationFrame>(16)

  // --------------------------------------------------------------------------
  ondestroy
    destroy m_factoryFunc
    for frame in m_freeList
      destroy frame
    destroy m_freeList

  // --------------------------------------------------------------------------
  function getFrame() returns NotificationFrame
    NotificationFrame frame
    if (m_freeList.isEmpty())
      frame = m_factoryFunc.createFrame()
      g_frameToPool.put(frame, this)
    else
      frame = m_freeList.pop()
    return frame

  // --------------------------------------------------------------------------
  function release(NotificationFrame frame)
    if (g_frameToPool.get(frame) != this)
      error("NotificationFrame does not belong to pool")
    releaseUnsafe(frame)
    
  // --------------------------------------------------------------------------
  protected function releaseUnsafe(NotificationFrame frame)
    m_freeList.push(frame)
    frame.setNotification(null)
    frame.getFrameHandle().hide()

// ============================================================================
public function NotificationFrame.release()
  let pool = g_frameToPool.get(this)
  if (pool != null)
    pool.release(this)
  else
    destroy this

// ============================================================================
init

  g_frameToPool = new HashMap<NotificationFrame, NotificationFramePool>()
  
  NotificationManager.notificationFrameFactory
  ..registerFactory(Notification.typeId, () -> new TextSimpleNotificationFrame(createFrame("SimpleNotification", CONSOLE_UI_BACKDROP, 0, 0)))
  ..registerFactory(ActionNotification.typeId, () -> new TextActionNotificationFrame(createFrame("ActionNotification", CONSOLE_UI_BACKDROP, 0, 0)))
  ..registerFactory(ChoiceNotification.typeId, () -> new TextChoiceNotificationFrame(createFrame("ChoiceNotification", CONSOLE_UI_BACKDROP, 0, 0)))