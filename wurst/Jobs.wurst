package Jobs
import LinkedList
import RealTime
import Trace
import ClosureTimers
import Action
import CancellationToken
import Events
import Func

constant int DEFAULT_MAX_WORK_PER_TICK = 8 // 1 per player?
constant real DEFAULT_PROCESS_INTERVAL = 0.1

// ============================================================================
public class JobThread
  private string m_id
  private LinkedList<Job> m_jobQueue = new LinkedList<Job>()
  private CallbackPeriodic m_processQueueCallback = null
  private bool m_enabled = false
  private int m_workCompletedCount = 0
  private int m_workTimeoutCount = 0
  private int m_workCanceledCount = 0
  private int m_maxWorkPerTick = DEFAULT_MAX_WORK_PER_TICK
  private real m_tickInterval = DEFAULT_PROCESS_INTERVAL
  private JobThread m_dependsOnThread = null

  static JobThread defaultQueue = new JobThread("default")..setEnabled(true)

  // --------------------------------------------------------------------------
  construct(string id)
    m_id = id
  
  // --------------------------------------------------------------------------
  function getEnabled() returns bool
    return m_enabled

  // --------------------------------------------------------------------------
  function setEnabled(bool enabled)
    m_enabled = enabled

  // --------------------------------------------------------------------------
  function getTickInterval() returns real
    return m_tickInterval

  // --------------------------------------------------------------------------
  function setTickInterval(real value)
    m_tickInterval = value
    if (m_processQueueCallback != null)
      stopProcessQueue()
      startProcessQueue()

  // --------------------------------------------------------------------------
  function getMaxWorkPerTick() returns int
    return m_maxWorkPerTick

  // --------------------------------------------------------------------------
  function setMaxWorkPerTick(int value)
    m_maxWorkPerTick = value

  // --------------------------------------------------------------------------
  function setDependsOnThread(JobThread otherThread)
    m_dependsOnThread = otherThread

  // --------------------------------------------------------------------------
  function getDependentThread() returns JobThread
    return m_dependsOnThread

  // --------------------------------------------------------------------------
  function enqueue(Job job)
    if (m_jobQueue.has(job))
      return
    m_jobQueue.add(job)
    startProcessQueue()

  // --------------------------------------------------------------------------
  private function startProcessQueue()
    if (m_processQueueCallback == null)
      m_processQueueCallback = doPeriodically(m_tickInterval, cb -> processQueue())
    
  // --------------------------------------------------------------------------
  private function stopProcessQueue()
    if (m_processQueueCallback != null)
      destroy m_processQueueCallback
      m_processQueueCallback = null

  // --------------------------------------------------------------------------
  function remove(Job job) returns bool
    let removed = m_jobQueue.remove(job)
    if (m_jobQueue.isEmpty())
      stopProcessQueue()
    return removed

  // --------------------------------------------------------------------------
  function getRemainingWorkCount() returns int
    return m_jobQueue.size()

  // --------------------------------------------------------------------------
  function getCompletedWorkCount() returns int
    return m_workCompletedCount

  // --------------------------------------------------------------------------
  function getCanceledWorkCount() returns int
    return m_workCanceledCount

  // --------------------------------------------------------------------------
  function getTimedOutWorkCount() returns int
    return m_workTimeoutCount

  // --------------------------------------------------------------------------
  function getQueue() returns LinkedList<Job>
    return m_jobQueue

  // --------------------------------------------------------------------------
  private function processQueue()
    
    if (not m_enabled)
      return

    if (m_jobQueue.isEmpty())
      stopProcessQueue()
      return

    if (m_dependsOnThread != null and
        m_dependsOnThread.getRemainingWorkCount() > 0)
      Trace.trace("Work.waitDependency")
      return

    Trace.trace("Work.processQueue")

    let iter = m_jobQueue.staticItr()
    iter.reset()
    
    var workCounter = 0
    var processCounter = 0
    while (workCounter < m_maxWorkPerTick)
    //{

      if (not iter.hasNext())
        if (m_jobQueue.isEmpty())
          break
        iter.reset()

      let job = iter.next()

      if (not job.getIsCancellationRequested() and job.hasNext())
        job.setStatus(JobStatus.RUNNING)
        processCounter++
        let work = job.next()
        if (work > 0)
          workCounter += work

      // Work has been cancelled (check again after work is done above)
      if (job.getIsCancellationRequested())
        job.setStatus(JobStatus.CANCELED)
        job.complete()
        m_workCanceledCount++
        iter.remove()
        job.close()

      // Work is done, close it out
      else if (not job.hasNext())
        job.setStatus(JobStatus.SUCCEEDED)
        job.complete()
        m_workCompletedCount++
        iter.remove()
        job.close()

      // Work timed out
      else if (job.didTimeout())
        job.setStatus(JobStatus.TIMEDOUT)
        job.complete()
        m_workTimeoutCount++
        iter.remove()
        job.close()

      // Still has more to spawn move it to the back of the line
      else if (iter.hasNext())
        iter.remove()
        m_jobQueue.add(job)

    //}

    iter.close()
    
    Trace.trace("Work.subWork", workCounter)
    Trace.trace("Work.items", processCounter)

    if (m_jobQueue.isEmpty())
      stopProcessQueue()

// ============================================================================
public enum JobStatus
  WAITING     // In queue, hasn't started yet
  RUNNING     // In queue and has been processed at least once
  SUCCEEDED   // Out of queue, no more work to do
  TIMEDOUT    // Out of queue, ran out of time
  CANCELED    // Out of queue, canceled by caller
  FAILED      // Out of queue, failed for some job-defined reason

// ============================================================================
public abstract class Job
  protected real m_timeout
  protected int m_startTime
  protected CancellationToken m_ct
  private JobStatus m_status = WAITING
  private Event1<Job> m_completedEvent = null
  private bool m_completed = false

  // --------------------------------------------------------------------------
  construct ()
    m_timeout = REAL_MAX
    m_startTime = getRealTimeSeconds()

  // --------------------------------------------------------------------------
  construct (real timeout)
    m_timeout = timeout
    m_startTime = getRealTimeSeconds()

  // --------------------------------------------------------------------------
  ondestroy
    if (m_completedEvent != null)
      destroy m_completedEvent
      m_completedEvent = null

    if (m_ct != null)
      m_ct.release()
      m_ct = null

  // --------------------------------------------------------------------------
  function onCompleted() returns IEvent1<Job>
    if (m_completedEvent == null)
      m_completedEvent = new Event1<Job>()
    return m_completedEvent

  // --------------------------------------------------------------------------
  function setCancellationToken(CancellationToken ct)
    if (m_ct != null)
      m_ct.release()
    m_ct = ct.acquire()

  // --------------------------------------------------------------------------
  function getCancellationToken() returns CancellationToken
    return m_ct

  // --------------------------------------------------------------------------
  function getIsCancellationRequested() returns bool
    return m_ct != null and m_ct.isCanceled()

  // --------------------------------------------------------------------------
  function cancel()
    if (m_ct == null)
      m_ct = new CancellationToken().acquire()
    m_ct.cancel()

  // --------------------------------------------------------------------------
  function getStatus() returns JobStatus
    return m_status

  // --------------------------------------------------------------------------
  protected function setStatus(JobStatus value)
    m_status = value

  // --------------------------------------------------------------------------
  function didTimeout() returns bool
    return (getRealTimeSeconds() - m_startTime) > m_timeout

  // --------------------------------------------------------------------------
  abstract function next() returns int

  // --------------------------------------------------------------------------
  abstract function hasNext() returns bool

  // --------------------------------------------------------------------------
  abstract function getDebuggerStateString() returns string

  // --------------------------------------------------------------------------
  function complete()
    if (m_completed)
      return

    m_completed = true

    completeInternal()

    if (m_completedEvent != null)
      m_completedEvent.call(this)

  // --------------------------------------------------------------------------
  function close()
    destroy this

  // --------------------------------------------------------------------------
  protected function completeInternal()
    skip

// ============================================================================
public class ActionJob extends Job
  private Action m_action
  private int m_counter

  // --------------------------------------------------------------------------
  construct(Action action)
    m_action = action.acquire()
    m_counter = 1

  // --------------------------------------------------------------------------
  construct(Action action, int timesToCall)
    m_action = action.acquire()
    m_counter = timesToCall

  // --------------------------------------------------------------------------
  ondestroy
    m_action.release()
    m_action = null

  // --------------------------------------------------------------------------
  override function next() returns int
    m_action.call()
    m_counter--
    return 1

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_counter > 0

  // --------------------------------------------------------------------------
  override function getDebuggerStateString() returns string
    return ""

// ============================================================================
public function JobThread.invoke(Action action) returns ActionJob
  let job = new ActionJob(action)
  this.enqueue(job)
  return job

// ============================================================================
public class Action1Job<TArg1> extends Job
  private Action1<TArg1> m_action
  private TArg1 m_arg1
  private int m_counter

  // --------------------------------------------------------------------------
  construct(Action1<TArg1> action, TArg1 arg1)
    m_action = action.acquire()
    m_arg1 = arg1
    m_counter = 1

  // --------------------------------------------------------------------------
  construct(Action1<TArg1> action, TArg1 arg1, int timesToCall)
    m_action = action.acquire()
    m_arg1 = arg1
    m_counter = timesToCall

  // --------------------------------------------------------------------------
  ondestroy
    m_action.release()
    m_action = null

  // --------------------------------------------------------------------------
  override function next() returns int
    m_action.call(m_arg1)
    m_counter--
    return 1

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_counter > 0

  // --------------------------------------------------------------------------
  override function getDebuggerStateString() returns string
    return ""

// // ============================================================================
// public function JobThread.invoke<TArg1>(Action1<TArg1> action, TArg1 arg1) returns Action1Job<TArg1>
//   let actionJob = new Action1Job<TArg1>(action, arg1)
//   this.enqueue(actionJob)
//   return actionJob

// ============================================================================
public class RepeatJob extends Job
  private Action1<int> m_action
  private int m_index
  private int m_count

  // --------------------------------------------------------------------------
  construct(int count, Action1<int> action)
    m_action = action.acquire()
    m_count = count
    m_index = 0

  // --------------------------------------------------------------------------
  ondestroy
    m_action.release()
    m_action = null

  // --------------------------------------------------------------------------
  override function next() returns int
    m_action.call(m_index)
    m_index++
    return 1

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return m_index < m_count

  // --------------------------------------------------------------------------
  override function getDebuggerStateString() returns string
    return ""

// ============================================================================
public function JobThread.repeat(int count, Action1<int> action) returns RepeatJob
  let job = new RepeatJob(count, action)
  this.enqueue(job)
  return job

// ============================================================================
public class FuncJob<TResult> extends Job
  private Func<TResult> m_func
  private TResult m_result
  private bool m_called
  private Event1<TResult> m_resultEvent

  // --------------------------------------------------------------------------
  construct(Func<TResult> func)
    m_func = func.acquire()

  // --------------------------------------------------------------------------
  ondestroy
    m_func.release()
    m_func = null

    if (m_resultEvent != null)
      destroy m_resultEvent
      m_resultEvent = null

  // --------------------------------------------------------------------------
  function getResult() returns TResult
    return m_result

  // --------------------------------------------------------------------------
  function onResult() returns IEvent1<TResult>
    if (m_resultEvent == null)
      m_resultEvent = new Event1<TResult>()
    return m_resultEvent

  // --------------------------------------------------------------------------
  override protected function completeInternal()
    if (m_resultEvent != null)
      m_resultEvent.call(m_result)

  // --------------------------------------------------------------------------
  override function next() returns int
    m_result = m_func.call()
    m_called = true
    return 1

  // --------------------------------------------------------------------------
  override function hasNext() returns bool
    return not m_called

  // --------------------------------------------------------------------------
  override function getDebuggerStateString() returns string
    return ""

// ============================================================================
public function JobThread.invokeFunc<TResult>(Func<TResult> func) returns FuncJob<TResult>
  let job = new FuncJob(func)
  this.enqueue(job)
  return job