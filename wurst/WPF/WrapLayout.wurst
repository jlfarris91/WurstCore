// package WrapLayout
// import Layout

// // ============================================================================
// public class WrapLayout
//   private rectr m_area
//   private vec2 m_spacing = ZERO2
//   private vec2 m_layoutPos = ZERO2
//   private vec2 m_layoutPosStart = ZERO2
//   private vec2 m_layoutDir = ZERO2
//   private Orientation m_orientation = HORIZONTAL
//   private HorizontalLayoutOrientation m_horizontalOrientation = LEFTTORIGHT
//   private VerticalLayoutOrientation m_verticalOrientation = TOPTOBOTTOM
//   private vec2 m_size
//   private int m_elementCount

//   // --------------------------------------------------------------------------
//   /// Defines which direction to move in first
//   function setOrientation(Orientation value)
//     m_orientation = value

//   // --------------------------------------------------------------------------
//   function getOrientation() returns Orientation
//     return m_orientation

//   // --------------------------------------------------------------------------
//   function setHorizontalOrientation(HorizontalLayoutOrientation value)
//     m_horizontalOrientation = value

//   // --------------------------------------------------------------------------
//   function getHorizontalOrientation() returns HorizontalLayoutOrientation
//     return m_horizontalOrientation

//   // --------------------------------------------------------------------------
//   function setVerticalOrientation(VerticalLayoutOrientation value)
//     m_verticalOrientation = value

//   // --------------------------------------------------------------------------
//   function getVerticalOrientation() returns VerticalLayoutOrientation
//     return m_verticalOrientation

//   // --------------------------------------------------------------------------
//   function setSpacing(vec2 value)
//     m_spacing = value

//   // --------------------------------------------------------------------------
//   function getSpacing() returns vec2
//     return m_spacing

//   // --------------------------------------------------------------------------
//   function getWidth() returns real
//     return m_size.x

//   // --------------------------------------------------------------------------
//   function getHeight() returns real
//     return m_size.y

//   // --------------------------------------------------------------------------
//   function reset(rectr area)
//     m_area = area
//     m_size = ZERO2
//     m_elementCount = 0
    
//     // Remember that x/y frame of reference is bottom left
//     switch (m_horizontalOrientation)
//       case LEFTTORIGHT      
//         m_layoutPos.x = m_area.left()
//         m_layoutDir.x = 1
//       case RIGHTTOLEFT
//         m_layoutPos.x = m_area.right()
//         m_layoutDir.x = -1

//     switch (m_verticalOrientation)
//       case BOTTOMTOTOP
//         m_layoutPos.y = m_area.bottom()
//         m_layoutDir.y = 1
//       case TOPTOBOTTOM
//         m_layoutPos.y = m_area.top()
//         m_layoutDir.y = -1

//     m_layoutPosStart = m_layoutPos

//   // --------------------------------------------------------------------------
//   function measure(vec2 desiredFrameSize) returns vec2



//     return desiredFrameSize

//   // --------------------------------------------------------------------------
//   function arrange(vec2 desiredFrameSize) returns rectr

//     // TODO: We have to do this because Frames are assumed to be BottomLeft-based
//     if (m_elementCount == 0)
//     //{
//       if (m_horizontalOrientation == RIGHTTOLEFT)
//         m_layoutPos.x -= desiredFrameSize.x
//       if (m_verticalOrientation == TOPTOBOTTOM)
//         m_layoutPos.y -= desiredFrameSize.y
//     //}

//     let framePos = m_layoutPos

//     // Prepare for the next frame
//     switch (m_orientation)
//       case HORIZONTAL
//         m_layoutPos = advanceHorizontally(m_layoutPos, desiredFrameSize)
//       case VERTICAL
//         m_layoutPos = advanceVertically(m_layoutPos, desiredFrameSize)

//     m_elementCount++

//     return rectr(framePos, desiredFrameSize)

//   // --------------------------------------------------------------------------
//   private function advanceHorizontally(vec2 layoutPos, vec2 frameSize) returns vec2

//     var pos = layoutPos

//     if (pos.x != m_layoutPosStart.x)
//       pos.x += m_spacing.x * m_layoutDir.x

//     pos.x += frameSize.x * m_layoutDir.x

//     switch (m_horizontalOrientation)
//     //{
//       case LEFTTORIGHT
//         if (pos.x > m_area.width)
//           pos = wrapHorizontally(pos, frameSize)
//       case RIGHTTOLEFT
//         if (pos.x < 0)
//           pos = wrapHorizontally(pos, frameSize)
//     //}

//     m_size.x = max(m_size.x, (pos.x - m_layoutPosStart.x).abs())
//     m_size.y = max(m_size.y, (pos.y - m_layoutPosStart.y).abs() + frameSize.y)

//     return pos

//   // --------------------------------------------------------------------------
//   private function wrapHorizontally(vec2 layoutPos, vec2 frameSize) returns vec2
//     var pos = layoutPos
//     pos.x = m_layoutPosStart.x
//     pos.y = m_layoutPosStart.y + m_size.y * m_layoutDir.y

//     // TODO: We have to do this because Frames are assumed to be BottomLeft-based
//     if (m_horizontalOrientation == RIGHTTOLEFT)
//       pos.x -= frameSize.x

//     return pos

//   // --------------------------------------------------------------------------
//   private function advanceVertically(vec2 layoutPos, vec2 frameSize) returns vec2

//     var pos = layoutPos

//     if (pos.y != m_layoutPosStart.y)
//       pos.y += m_spacing.y * m_layoutDir.y

//     pos.y += frameSize.y * m_layoutDir.y

//     switch (m_verticalOrientation)
//     //{
//       case BOTTOMTOTOP
//         if (pos.y > m_area.height)
//           pos = wrapVertically(pos, frameSize)
//       case TOPTOBOTTOM
//         if (pos.y < 0)
//           pos = wrapVertically(pos, frameSize)
//     //}
    
//     m_size.x = max(m_size.x, (pos.x - m_layoutPosStart.x).abs() + frameSize.x)
//     m_size.y = max(m_size.y, (pos.y - m_layoutPosStart.y).abs())

//     return pos

//   // --------------------------------------------------------------------------
//   private function wrapVertically(vec2 layoutPos, vec2 frameSize) returns vec2
//     var pos = layoutPos
//     pos.x = m_layoutPosStart.x + m_size.x * m_layoutDir.x
//     pos.y = m_layoutPosStart.y
    
//     // TODO: We have to do this because Frames are assumed to be BottomLeft-based
//     if (m_verticalOrientation == TOPTOBOTTOM)
//       pos.y -= frameSize.y

//     return pos