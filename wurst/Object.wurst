package Object
import Meta
import ErrorHandling
import public initlater HandleObjects
import Bitwise

public tuple object(int objectHandle, int objectTypeId)

public constant object NULL = object(0, 0)

constant int OBJECT_INDEX_HANDLE_MASK = 0xFFFFF   // Max number of handles supported is 1048575
constant int OBJECT_INDEX_TYPEID_MASK = 0xFFF     // Max number of types supported is 4095

// ============================================================================
@compiletime function assertTypeCount()
  if (maxTypeId() > OBJECT_INDEX_TYPEID_MASK)
    compileError("Too many types defined to safely use the Object library. Total: {0} Max allowed: {1}".format(maxTypeId().toString(), OBJECT_INDEX_TYPEID_MASK.toString()))

// ============================================================================
public function objectFromIndex(int index) returns object
  return object(index.and32(OBJECT_INDEX_HANDLE_MASK), index.shiftr(20).and32(OBJECT_INDEX_TYPEID_MASK))

// ============================================================================
public function objectToIndex(object obj) returns int
  // ((typeId & 0xFFF) << 20) | (handle & 0xFFFFF)
  return obj.objectTypeId.and32(OBJECT_INDEX_TYPEID_MASK).shiftl(20)
   .or32(obj.objectHandle.and32(OBJECT_INDEX_HANDLE_MASK))

// ============================================================================
public function object.is(int expectedTypeId) returns bool
  return Meta.is(this.objectTypeId, expectedTypeId)

// ============================================================================
/** Attempts to cast the object to the given type T. Unlike cast<T> this method
    will not throw an error if the cast cannot be completed successfully.
    Null is returned if:
    1) no metadata has been registered for expectedTypeId or object.objectTypeId
    2) object.objectTypeId is not a part of the inheritence chain of expectedTypeId
*/
public function object.as<T>(int expectedTypeId) returns T
  return Meta.is(this.objectTypeId, expectedTypeId) ? this.objectHandle castTo T : null

// ============================================================================
public function object.cast<T>(int expectedTypeId) returns T
  if (expectedTypeId == 0)
    error("[object.cast] Argument invalid: expectedTypeId must be greater than 0")
  if (this == NULL)
    return null
  if (this.objectTypeId == 0)
    error("[object.cast] Argument invalid: object.objectTypeId must be greater than 0")
  let metaType = Meta.getType(this.objectTypeId)
  if (metaType == null)
    error("[object.cast] No meta type registered for object type {0}".format(this.getTypeName()))
  if (metaType.is(expectedTypeId) == false)
    error("[object.cast] Type cast failed. Object: {0} ({1}) Expected: {2} ({3})".format(this.getTypeName(), this.objectTypeId.toString(), Meta.getTypeName(expectedTypeId), expectedTypeId.toString()))
  return this.objectHandle castTo T

// ============================================================================
public function object.castUnsafe<T>() returns T
  return this.objectHandle castTo T

// ============================================================================
public function object.isNull() returns bool
  return this.objectHandle == 0

// ============================================================================
public function object.isTyped() returns bool
  return this.objectTypeId != 0 and Meta.getType(this.objectTypeId) != null

// ============================================================================
public function object.getType() returns Type
  return Meta.getType(this.objectTypeId)

// ============================================================================
public function object.getTypeName() returns string
  return Meta.getTypeName(this.objectTypeId)

// ============================================================================
public function object.destr()
  if (this == NULL)
    error("Calling destroy on a NULL object")
  if (this.isTyped() == false)
    error("Calling destroy on a typeless object")
  let _type = this.getType()
  if (_type == null)
    error("No meta type registered for object type {0}".format(this.getTypeName()))
  let concreteType = _type castTo ConcreteType
  if (concreteType == null)
    error("Calling destroy on a type classification that does not support destruction: " + _type.getClassification().toString())
  concreteType.destroyObject(this)

// ============================================================================
public function toObject<T>(T source, int objectTypeId) returns object
  if (objectTypeId == 0)
    error("Argument invalid: objectTypeId must be greater than 0")
  let t = Meta.getType(objectTypeId)
  if (t == null)
    error("No meta type registered for object type {0}".format(Meta.getTypeName(objectTypeId)))
  return object(source castTo int, objectTypeId)

// ============================================================================
public function toObjectUnsafe<T>(T source) returns object
  return object(source castTo int, OBJECT_INDEX_TYPEID_MASK)

// ============================================================================
public function toObjectRef<T>(T source, int objectTypeId) returns Object
  return toObject<T>(source, objectTypeId).ref()

// ============================================================================
public class Object
  private object m_object

  // --------------------------------------------------------------------------
  construct (object object)
    m_object = object

  // --------------------------------------------------------------------------
  function getObject() returns object
    return m_object

  // --------------------------------------------------------------------------
  function setObject(object value)
    m_object = value

  // --------------------------------------------------------------------------
  function is(int expectedTypeId) returns bool
    return m_object.is(expectedTypeId)

  // --------------------------------------------------------------------------
  function as<T>(int expectedTypeId) returns T
    return m_object.as<T>(expectedTypeId)

  // --------------------------------------------------------------------------
  function cast<T>(int expectedTypeId) returns T
    return m_object.cast<T>(expectedTypeId)

  // --------------------------------------------------------------------------
  function castUnsafe<T>() returns T
    return m_object.castUnsafe<T>()
    
  // --------------------------------------------------------------------------
  function isNull() returns bool
    return m_object.isNull()

  // --------------------------------------------------------------------------
  function isTyped() returns bool
    return m_object.isTyped()

  // --------------------------------------------------------------------------
  function getType() returns Type
    return m_object.getType()

  // --------------------------------------------------------------------------
  function getTypeName() returns string
    return m_object.getTypeName()

// ============================================================================
public function object.ref() returns Object
  return new Object(this)

// ============================================================================
public interface ObjectFactory
  function call() returns object

// ============================================================================
public interface ObjectFactory1
  function call(object arg) returns object

// ============================================================================
public interface ObjectDestructor
  function call(object object)

// ============================================================================
@test function objectToIndex_NULL()
  let h = 0
  let t = 0
  let i = objectToIndex(object(h, t))
  i.assertEquals(0)

// ============================================================================
@test function objectToIndex1()
  let h = 1234
  let t = 1234
  let i = objectToIndex(object(h, t))
  i.assertEquals(0x4D2004D2)

// ============================================================================
@test function objectToIndex2()
  let h = 0xFFFFF
  let t = 0xFFF
  let i = objectToIndex(object(h, t))
  i.assertEquals(0xFFFFFFFF)