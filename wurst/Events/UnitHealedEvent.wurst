package UnitHealedEvent
import UnitIndexer
import initlater Events
import LinkedList
import ClosureTimers

constant real HEAL_THRESHOLD = 1.0
constant real INVALID_HP = -1
constant real UPDATE_INTERVAL = 0.1
real array g_lastKnownHP
unit array g_healSource
LinkedList<unit> g_trackedUnits

// ============================================================================
public class UnitHealedEventArgs
  private unit m_healingSource
  private unit m_healedUnit
  private real m_healedAmount

  // --------------------------------------------------------------------------
  construct(unit healingSource, unit unitHealed, real healedAmount)
    m_healingSource = healingSource
    m_healedUnit = unitHealed
    m_healedAmount = healedAmount

  function getHealingSource() returns unit
    return m_healingSource

  // --------------------------------------------------------------------------
  function getHealedUnit() returns unit
    return m_healedUnit

  // --------------------------------------------------------------------------
  function getAmountHealed() returns real
    return m_healedAmount

// ============================================================================
public class UnitHealedEvent extends AnonymousArgsEvent<UnitHealedEventArgs>

// ============================================================================
function updateLastKnownHP(unit u)

  if (u.isInvulnerable())
    onUnitDeindexed(u)
    return

  let lastKnownHP = g_lastKnownHP[u.getIndex()]
  let currentHP = u.getHP()

  // Record current hp
  g_lastKnownHP[u.getIndex()] = currentHP

  if (lastKnownHP != INVALID_HP)
    let deltaHP = currentHP - lastKnownHP

    // Unit was healed
    if (deltaHP > HEAL_THRESHOLD)
      onUnitHealed(u, deltaHP)

// ============================================================================
function onUnitHealed(unit u, real deltaHP)
  let index = u.getIndex()
  let healingSource = g_healSource[index]
  raiseUnitHealedEvent(healingSource, u, deltaHP)
  g_healSource[index] = null

  if (healingSource != null)
    Log.debug(healingSource.getName() + " healed " + u.getName() + " for " + R2S(deltaHP) + " hp")
  else
    Log.debug(u.getName() + " was healed for " + R2S(deltaHP) + " hp")

// ============================================================================
function clearLastKnownHP(unit u)
  g_lastKnownHP[u.getIndex()] = INVALID_HP

// ============================================================================
public function recordHealingAction(unit source, unit target)
  let targetIndex = target.toUnitIndex() castTo int
  if (targetIndex == 0)
    return
  g_healSource[targetIndex] = source

// ============================================================================
function raiseUnitHealedEvent(unit healingSource, unit unitHealed, real healedAmount)
  let args = new UnitHealedEventArgs(healingSource, unitHealed, healedAmount)
  PlayerUnitEvents.unitHealed.invoke(args)
  destroy args

// ============================================================================
function updateTrackedUnits()
  for u in g_trackedUnits
    updateLastKnownHP(u)

// ============================================================================
function onUnitIndexed(unit u)
  if (not u.isInvulnerable())
    g_trackedUnits.add(u)
    g_lastKnownHP[u.getIndex()] = u.getHP()

// ============================================================================
function onUnitDeindexed(unit u)
  g_trackedUnits.remove(u)
  clearLastKnownHP(u)

// ============================================================================
init
  g_trackedUnits = new LinkedList<unit>()

  onUnitIndex(() -> onUnitIndexed(getIndexingUnit()))
  onUnitDeindex(() -> onUnitDeindexed(getIndexingUnit()))

  doPeriodically(UPDATE_INTERVAL, (CallbackPeriodic cb) -> updateTrackedUnits())